# -*- coding: utf-8 -*-
"""Capstone_Bike_dataset

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1--1imZGSRxxCrtkng59Zq345ioWOKNY0
"""

pip install ucimlrepo

from ucimlrepo import fetch_ucirepo
import pandas as pd

# fetch dataset
seoul_bike_sharing_demand = fetch_ucirepo(id=560)

# data (as pandas dataframes)
X = seoul_bike_sharing_demand.data.features
y = seoul_bike_sharing_demand.data.targets

bike_df = pd.concat([X, y], axis=1)

# Display the first 10 rows of the combined DataFrame
bike_df.head(10)

#check the data types of the variables
bike_df.dtypes

#check if there are missing values in the datset
bike_df.isnull().sum()

#check if there are duplicated data
bike_df.duplicated().sum()

#show the basic statistics description
bike_df.describe(include='all')

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Filter only numeric columns
numeric_bike_df = bike_df.select_dtypes(include=[np.number])

plt.figure(figsize=(16, 6))
heatmap = sns.heatmap(numeric_bike_df.corr(), vmin=-1, vmax=1, annot=True, cmap='BrBG')
heatmap.set_title('Correlation Heatmap', fontdict={'fontsize':18}, pad=12);
# save heatmap as .png file
# dpi - sets the resolution of the saved image in dots/inches
# bbox_inches - when set to 'tight' - does not allow the labels to be cropped
plt.savefig('heatmap.png', dpi=300, bbox_inches='tight')

plt.show()

# Create a histogram for the 'Rented Bike Count' column
plt.hist(bike_df['Rented Bike Count'], bins=20, color='skyblue', edgecolor='black')

# Add labels and title
plt.xlabel('Rented Bike Count')
plt.ylabel('Frequency')
plt.title('Distribution of Rented Bike Count')

# Adjust x-axis range
plt.xlim(0, bike_df['Rented Bike Count'].max())

# Show the plot
plt.show()

import matplotlib.pyplot as plt
# Create a boxplot for the 'Rented Bike Count' to find out the outliers
plt.figure(figsize=(8, 6))
plt.boxplot(bike_df['Rented Bike Count'], vert=False)
# Add labels and title
plt.xlabel('Rented Bike Count')
plt.title('Boxplot of Rented Bike Count')
# Show the plot
plt.show()

import numpy as np

# calculate the upper bound/ outer upper fence of rented bike count

# Calculate the lower quartile
Q1 = np.percentile(bike_df['Rented Bike Count'], 25)
# Calculate the upper quartile
Q3 = np.percentile(bike_df['Rented Bike Count'], 75)

IQR = Q3 - Q1

# Calculate the upper bound
upper_bound = Q3 + 1.5 * IQR

print("Upper Bound for Outliers:", upper_bound)

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

#the instances are outliers if rented bike counts are more than 2376.625
condition = bike_df["Rented Bike Count"] > 2376.625
#red represents outliers and blue represents non-outliers
colors = np.where(condition, 'red', 'blue')

# Plot the scatter plot with different colors based on the condition
scatter = plt.scatter(bike_df['Temperature'], bike_df["Rented Bike Count"], c=colors, cmap='coolwarm')
plt.xlabel('Temperature')
plt.ylabel('Rented Bike Count')
plt.title('Temperature vs Hourly Rented Bike Count')
# Create a custom legend
red_patch = mpatches.Patch(color='red', label='Outlier')
blue_patch = mpatches.Patch(color='blue', label='Non-outlier')
plt.legend(handles=[red_patch, blue_patch])

plt.show()

#the instances are outliers if rented bike counts are more than 2376.625
condition = bike_df["Rented Bike Count"] > 2376.625
#red represents outliers and blue represents non-outliers
colors = np.where(condition, 'red', 'blue')

# Plot the scatter plot with different colors based on the condition
scatter = plt.scatter(bike_df['Hour'], bike_df["Rented Bike Count"], c=colors, cmap='coolwarm')
plt.xlabel('Hour')
plt.ylabel('Rented Bike Count')
plt.title('Hour vs Rented Bike Count')

# Create a custom legend
red_patch = mpatches.Patch(color='red', label='Outlier')
blue_patch = mpatches.Patch(color='blue', label='Non-outlier')
plt.legend(handles=[red_patch, blue_patch])

plt.show()

plt.figure(figsize=(12, 6))

# Group the data by 'Hour', 'Seasons', and calculate the mean 'Rented Bike Count' for each hour and season
hourly_season_counts = bike_df.groupby(['Hour', 'Seasons'])['Rented Bike Count'].mean().unstack()

# Plot a line plot for each season
for season in hourly_season_counts.columns:
    plt.plot(hourly_season_counts.index, hourly_season_counts[season], marker='o', label=season)

plt.xlabel('Hour')
plt.ylabel('Rented Bike Count')
plt.title('Average Rented Bike Count by Hour and Season')
plt.legend()
plt.xlim(-0.5, 23.5)
# make x-axis ticks to show all 24 hours
plt.xticks(range(24))

plt.show()

figsize_season_count = (12, 1.2 * len(bike_df['Holiday'].unique()))

# Create a figure and axis
fig, ax = plt.subplots(figsize=figsize_season_count)

# Plot violin plot with boxplot inside
sns.violinplot(data=bike_df, x='Rented Bike Count', y='Holiday', inner='box', palette='Dark2',
               linewidth=1.5, width=0.8, alpha=0.8, ax=ax)

# Set title
ax.set_title('Hourly Rented Bike Count by Holiday/ Non-holiday', fontsize=14)

# Show the plot
plt.show()

# Convert the column 'Date' in bike_df into a datetime format '%d/%m/%Y'
bike_df['Date'] = pd.to_datetime(bike_df['Date'], format='%d/%m/%Y')

# Separate Day, Month, and Year from 'Date'
bike_df['Day'] = bike_df['Date'].dt.day
bike_df['Month'] = bike_df['Date'].dt.month
bike_df['Year'] = bike_df['Date'].dt.year

# Group by month and calculate mean rented bike count
bike_Monthly_count = bike_df.groupby('Month')['Rented Bike Count'].mean().reset_index()

# Create a bar chart
plt.figure(figsize=(10, 5))
plt.bar(bike_Monthly_count['Month'], bike_Monthly_count['Rented Bike Count'], color='skyblue')

plt.xlabel('Month')
plt.ylabel('Rented Bike Count')
plt.title('Average Hourly Rented Bike Count by Month')
plt.grid(True)
plt.xticks(bike_Monthly_count['Month'], ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])

plt.show()